---
layout: post
title: "Deploy OAuth2 Proxy on Kubernetes with Azure AD"
subtitle: Using Traefik reverse proxy via Flux and Helm
date: 2023-05-22T20:30:00+01:00
background: '/assets/images/oauth2-proxy.png'
---

<div id="toc_container">
    <p class="toc_title">Contents</p>
    <ul class="toc_list">
      <li><a href="#What_is_oauth_proxy">What is Oauth2 Proxy?</a></li>
      <li><a href="#Setup_for_azure_ad">Setup for Azure AD</a></li>
      <li><a href="#k8s_with_flux_helm">Deploying OAuth2 Proxy to Kubernetes using Flux and Helm</a></li>
      <ol><a href="#Deploying_helm_repo">Deploying the helm repository</a></ol>
      <ol><a href="#Deploying_helm_release">Deploying the helm release</a></ol>
      <ol><a href="#Config_options">Configuration options</a></ol>
      <ol><a href="#Deploying_ingress">Deploying the ingress</a></ol>
      <ol><a href="#Deploying_middleware">Deploying the middlewares</a></ol>
      <li><a href="#Checking_progress">Checking progress</a></li>
      <li><a href="#Deploying_application">Deploying an application behind OAuth2 Proxy</a></li>
      <ol><a href="#Deploying_git_repo">Deploying the git repository</a></ol>
      <ol><a href="#Deploying_helm_release_2">Deploying the helm release</a></ol>
      <ol><a href="#Deploying_ingress_2">Deploying the ingress</a></ol>
      <li><a href="#Ideal_setup">Ideal setup</a></li>
      <ol><a href="#k8s_secrets">Using kubernetes secrets</a></ol>
      <li><a href="#Extras">Extras</a></li>
      <ol><a href="#Redis_cache">Redis cache</a></ol>
      <li><a href="#Summary">Summary</a></li>

    </ul>
</div>


<p>In this tutorial, we will be deploying OAuth2 Proxy to a kubernetes cluster using Azure Active Directory as the authentication provider and Traefik as the reverse proxy.</p>
<p>We will also be using FluxCD with Kustomize to deploy Kubernetes resources via Helm.</p>
<p>Requirements:</p>

<ul>
    <li><a href="https://www.microsoft.com/en-us/security/business/identity-access/azure-active-directory-enable" target="_blank">Azure AD tenant</a></li>
    <li>domain name</li>
    <li>git repository</li>
    <li><a href="https://fluxcd.io/flux/get-started/" target="_blank">Flux</a></li>
    <li>kubernetes cluster</li>
    <li><a href="https://kubernetes.io/docs/tasks/tools" target="_blank">Kubectl</a> tool installed your computer</li>
    <li>tls certificates configured on your cluster</li>
</ul>

<p>You can also deploy the helm releases we will be using manually by running <code>kubectl apply -f helmrelease.yaml</code> if you don't want to set up Flux. You can also avoid having to use TLS certificates if you're just testing this out locally but the guide will assume you are using all of the above.
</p>
<h1 id="What_is_oauth_proxy">What is Oauth2 Proxy?</h1>
</p>
<p>If you have an application you want to make available on the internet but you want to grant access only to authorised users, you can use OAuth2 Proxy to force visitors to authenticate with an authentication provider like Google or Microsoft.
</p>
<p>The tool is mainly focused on using NGINX reverse proxy so much of the official documentation is around that technology. This guide will give you guidance on how to use OAuth2 Proxy with Traefik reverse proxy which requires some specific setup to work.
</p>
<h1 id="Set_up_for_Azure_AD">Set up for Azure AD</h1>
</p>
<p>The official docs have clear guidance on setting up an application registration in Azure Active Directory. Follow their <a href="https://oauth2-proxy.github.io/oauth2-proxy/configuration/providers/azure" target="_blank">docs</a> for this step and come back here once you've completed that.
</p>
<p>For this we will be using the v1 endpoint but I have also enabled the v2 endpoint in the application manifest as per point 4 in the linked guide.
</p>
<h1 id="Deploying_to_k8s">Deploying OAuth2 Proxy to Kubernetes using Flux and Helm</h1>
</p>
<p>There is an official helm chart provided by the developers of OAuth2 Proxy.
</p>
<p>The source code for this can be found on <a href="https://github.com/oauth2-proxy/manifests" target="_blank">GitHub</a>.
</p>
<p>The following kubernetes manifests will get you up and running but there are slight improvements to be made to these configs which we will explore later on in the guide e.g. using kubernetes secrets.
</p>
<h2 id="Deploying_helm_repo">Deploying the helm repository</h2>
</p>
<p>In your git repository, add the helm repository to install the chart on the cluster:
</p>
<details>

<summary>View code</summary>

{% highlight yaml %}

apiVersion: source.toolkit.fluxcd.io/v1beta2

kind: HelmRepository

metadata:

  name: oauth2-proxy-charts

  namespace: default

spec:

  interval: 1h

  url: https://oauth2-proxy.github.io/manifests

  timeout: 3m

{% endhighlight %}


</details>
<p></p>
<h2 id="deploying_helm_release">Deploying the helm release</h2>
<p></p>
Create a helm release and replace the example values like <code>domain.com</code> with your own values.
<p></p>
<details>

<summary>View code</summary>

{% highlight yaml %}

apiVersion: helm.toolkit.fluxcd.io/v2beta1

kind: HelmRelease

metadata:

  name: oauth2-proxy

  namespace: default

spec:

  releaseName: oauth2-proxy

  chart:

    spec:

      chart: oauth2-proxy

      version: 6.12.0

      sourceRef:

	kind: HelmRepository

	name: oauth2-proxy-charts

	namespace: default

  interval: 5m

  values:

    extraArgs:

      cookie-domain: ".domain.com, .domain.net"

      email-domain: "domain.com"

      pass-authorization-header: true

      pass-basic-auth: false

      pass-host-header: true

      pass-user-headers: true

      provider: "azure"

      redirect-url: https://oauth2-proxy-01.domain.com/oauth2/callback

      reverse-proxy: true

      set-authorization-header: true

      set-xauthrequest: true

      show-debug-on-error: true

      skip-provider-button: true

      silence-ping-logging: true

      upstream: static://202

      whitelist-domain: ".domain.com"

      client-id: "<CLIENT-ID>"

      client-secret: "<CLIENT-SECRET>"

      cookie-secret: <COOKIE-SECRET>"

      oidc-issuer-url: "https://sts.windows.net/<TENANT-ID>/"

      extra-jwt-issuers: "https://login.microsoftonline.com/<TENANT-ID>/v2.0=<CLIENT-ID>"

      azure-tenant: "<TENANT-ID>"

    redis:

      enabled: false

    ingress:

      annotations:

	traefik.ingress.kubernetes.io/router.tls: "true"

      className: traefik

      enabled: true

      hosts:

	- oauth2-proxy-01.domain.com

{% endhighlight %}

</details>

<p></p>

<h3 id="Config_options">Configuration options</h3>
</p>
<p>You can find explanations for what these options mean in the <a href="https://oauth2-proxy.github.io/oauth2-proxy/configuration/overview" target="_blank">Oauth2 Proxy docs</a> but I want to give you some pointers on why these particular arguments are useful / required.
</p>

<table style="table-layout: auto; width: 100%">
    <tr>
        <th>Argument</th>
        <th>Example Value</th>
        <th>Why is it needed?</th>
      </tr>
      <tr>
        <td style="word-wrap: break-word"> Azure tenant</td>
        <td style="word-wrap: break-word"> "abcd1234-5678-91ef-23gh-ij4kl5mn6o"</td>
        <td style="word-wrap: break-word"> Your Azure AD tenant id</td>
      </tr>
      <tr>
        <td border: 1px solid; style="word-wrap: break-word"> client-id</td>
        <td border: 1px solid; style="word-wrap: break-word"> "abcd1234-5678-91ef-23gh-ij4kl5mn6o"</td>
        <td border: 1px solid; style="word-wrap: break-word"> The client id of the app registration you will have created in Azure AD</td>
      </tr>
      <tr>
        <td style="word-wrap: break-word">   client-secret</td>
        <td style="word-wrap: break-word">   "abcdefghijklmnopqrstuvwxyz1234456789?~!@$%"</td>
        <td style="word-wrap: break-word">   The client secret you will have generated for the app registration in Azure AD</td>
      </tr>
      <tr>
        <td style="word-wrap: break-word"> cookie-domain</td>
        <td style="word-wrap: break-word"> ".domain.com, .domain.net"</td>
        <td style="word-wrap: break-word"> Used to cache cookies for the correct domain. It can be set to "*" to allow all domains</td>
      </tr>
      <tr>
        <td style="word-wrap: break-word"> cookie-secret</td>
        <td style="word-wrap: break-word"> "wj7fY0MwSPKZZoxUaUNnoeqgN0lEr5f-F6vGIFO1AR4="</td>
        <td style="word-wrap: break-word"> A randomly generated secret from the command line on your computer. See <a href="https://oauth2-proxy.github.io/oauth2-proxy/configuration/overview#generating-a-cookie-secret" target="_blank">here</a></td>
      </tr>
      <tr>
        <td style="word-wrap: break-word"> email-domain</td>
        <td style="word-wrap: break-word"> "domain.com"</td>
        <td style="word-wrap: break-word"> Can be used to restrict sign in to only certain domains. Use "*" to allow all domains</td>
      </tr>
      <tr>
        <td style="word-wrap: break-word"> extra-jwt-issuers</td>
        <td style="word-wrap: break-word"> "https://login.microsoftonline.com/YOUR-TENANT-ID/v2.0=YOUR-CLIENT-ID"</td>
        <td style="word-wrap: break-word"> A list of extra JSON Web Token (JWT) issuer URLs. This is needed as there are two endpoints that Azure AD offers for authentication </td>
      </tr>
      <tr>
        <td style="word-wrap: break-word"> oidc-issuer-url</td>
        <td style="word-wrap: break-word"> "https://sts.windows.net/YOUR-TENANT-ID/"</td>
        <td style="word-wrap: break-word"> The OpenID Connect issuer URL for your provider, in this case, Azure AD</td>
      </tr>
      <tr>
        <td style="word-wrap: break-word"> pass-authorization-header </td>
        <td style="word-wrap: break-word"> true </td>
        <td style="word-wrap: break-word"> Pass OIDC IDToken to upstream via Authorization Bearer header </td>
      </tr>
      <tr>
        <td style="word-wrap: break-word"> pass-basic-auth </td>
        <td style="word-wrap: break-word"> false </td>
        <td style="word-wrap: break-word"> Pass HTTP Basic Auth, X-Forwarded-User, X-Forwarded-Email and X-Forwarded-Preferred-Username information to upstream. Set to <code>false</code> for Azure AD. </td>
      </tr>
      <tr>
        <td style="word-wrap: break-word"> pass-host-header </td>
        <td style="word-wrap: break-word"> true </td>
        <td style="word-wrap: break-word"> Pass the request Host Header to upstream </td>
      </tr>
      <tr>
        <td style="word-wrap: break-word"> pass-user-headers </td>
        <td style="word-wrap: break-word"> true </td>
        <td style="word-wrap: break-word"> Pass X-Forwarded-User, X-Forwarded-Groups, X-Forwarded-Email and X-Forwarded-Preferred-Username information to upstream </td>
      </tr>
      <tr>
        <td style="word-wrap: break-word"> provider </td>
        <td style="word-wrap: break-word"> "azure" </td>
        <td style="word-wrap: break-word"> The authentication provider you want to use e.g. <code>google</code> for Google or <code>azure</code> for Azure AD </td>
      </tr>
      <tr>
        <td style="word-wrap: break-word"> redirect-url </td>
        <td style="word-wrap: break-word"> https://oauth2-proxy-01.domain.com/oauth2/callback </td>
        <td style="word-wrap: break-word"> The redirect URL for OAuth2 Proxy. Tells your request where to go once authenticated. You will have to enter this in the <code>Redirect URIs</code> section of your app registration in Azure AD </td>
      </tr>
      <tr>
        <td style="word-wrap: break-word"> reverse-proxy </td>
        <td style="word-wrap: break-word"> true </td>
        <td style="word-wrap: break-word"> Tells OAuth2 Proxy that it's running behind a reverse proxy i.e. Traefik </td>
      </tr>
      <tr>
        <td style="word-wrap: break-word"> set-authorization-header </td>
        <td style="word-wrap: break-word"> true </td>
        <td style="word-wrap: break-word"> Set Authorization Bearer response header (useful in Nginx auth_request mode) </td>
      </tr>
      <tr>
        <td style="word-wrap: break-word"> set-xauthrequest </td>
        <td style="word-wrap: break-word"> true </td>
        <td style="word-wrap: break-word"> Set X-Auth-Request-User, X-Auth-Request-Groups, X-Auth-Request-Email and X-Auth-Request-Preferred-Username response headers (useful in Nginx auth_request mode). When used with --pass-access-token, X-Auth-Request-Access-Token is added to response headers. </td>
      </tr>
      <tr>
        <td style="word-wrap: break-word"> show-debug-on-error </td>
        <td style="word-wrap: break-word"> true </td>
        <td style="word-wrap: break-word"> Show more informative error messages in the kubernetes pod logs </td>
      </tr>
      <tr>
        <td style="word-wrap: break-word"> silence-ping-logging </td>
        <td style="word-wrap: break-word"> true </td>
        <td style="word-wrap: break-word"> Hides ping messages in the log. These aren't very useful and clutter the log </td>
      </tr>
      <tr>
        <td style="word-wrap: break-word"> skip-provider-button </td>
        <td style="word-wrap: break-word"> true </td>
        <td style="word-wrap: break-word"> There is an option to show an interstitial page giving you the option to choose your authentication provider. Useful if you are using multiple authentication methods </td>
      </tr>
      <tr>
        <td style="word-wrap: break-word"> upstream </td>
        <td style="word-wrap: break-word"> static://202 </td>
        <td style="word-wrap: break-word"> The upstream page to show when you've connected and authenticated directly to the OAuth2 Proxy. You could set this to an application URL if you want to redirect to a default application but this static page is enough to tell you the OAuth2 Proxy is working. When you authenticate, it will show a simple page saying <code>Authenticated</code></td>
      </tr>
      <tr>
        <td style="word-wrap: break-word"> whitelist-domain </td>
        <td style="word-wrap: break-word"> ".domain.com" </td>
        <td style="word-wrap: break-word"> Domain names you want to allow redirection to. Similar to email domains but for the destination application rather than the user </td>
      </tr>
</table>

<p>	
</p>
<p>Redis can be deployed in instances where the cookies are too large and cause issues with authenticating to your application. This can be the case in some applications that support Single Sign On (SSO). Our ideal setup will have redis enabled and we will come back to this later.
</p>
<h2 id="Deploying_ingress">Deploying the ingress</h3>
</p>
<p>The chart contains an ingress controller template as per the example above. You will need to create an ingressClass by deploying Traefik using their <a href="https://github.com/traefik/traefik-helm-chart/tree/master/traefik" target="_blank">official helm chart</a>. The ingressClass will be named after your traefik helm release. If you use the file below, your ingressClass will be called <code>traefik</code>. Replace <code>X.X.X.X</code> with an appropriate IP address.
</p>
<p><details>
</p>
<summary>View code</summary>
{% highlight yaml %}

apiVersion: helm.toolkit.fluxcd.io/v2beta1

kind: HelmRelease

metadata:

  name: traefik

  namespace: default

spec:

  values:

    ingressRoute:

      dashboard:

        enabled: false

    globalArguments:

      - --global.sendanonymoususage=false

    ingressClass:

      enabled: true

      isDefaultClass: true

    logs:

      general:

        level: DEBUG

      access:

        enabled: true

    ports:

      traefik:

        expose: true

      web:

        redirectTo: websecure

    service:

      spec: 

        loadBalancerIP: "X.X.X.X"

  chart:

    spec:

      chart: traefik

      version: 23.0.1

      sourceRef:

        kind: HelmRepository

        name: traefik-charts

        namespace: default

  interval: 5m

{% endhighlight %}

	
</p>
<p></details><br>
</p>
<p>The annotation <code>traefik.ingress.kubernetes.io/router.tls: "true"</code> will tell Traefik to use https instead of http with a TLS certificate. You will need to configure a TLS certificate on your cluster to avoid certificate error messages in your browser from using the certificate that comes with Traefik which won't be trusted.
</p>
<p>This is coupled with <code>web: redirectTo: websecure</code> which will redirect http requests to https.
</p>
<p>There are many ways to deploy and use certificates with Traefik that will depend on your setup so we won't go into that in depth here. If you've never set something like this up before, the cert-manager <a href="https://cert-manager.io/docs/" target="_blank">docs</a> are a good resource to get started with.
</p>
<p>If you're just testing this all out locally, you can set <code>traefik.ingress.kubernetes.io/router.tls</code> to false or not set it at all and remove the redirect so it only uses http, however, I have not tested this approach specifically for this guide and you may run into issues with the Azure AD application registration as it requires https redirect URIs unless you can use <code>http://localhost</code>.
</p>
<h2 id="Deploying_middlewares">Deploying the middlewares</h2>
</p>
<p>Create the required middlewares:
</p>
<p><details>
</p>
<summary>View code</summary>
{% highlight yaml %}

apiVersion: traefik.containo.us/v1alpha1

kind: Middleware

metadata:

  name: oauth-auth

  namespace: default

spec:

  forwardAuth:

    address: http://oauth2-proxy.default/oauth2/auth_or_start

    trustForwardHeader: true

    authResponseHeaders:

      - X-Auth-Request-Access-Token

      - Authorization

      - X-Auth-Request-User

      - X-Auth-Request-Email

      - X-Auth-Email

      - X-Auth-Username

---

apiVersion: traefik.containo.us/v1alpha1

kind: Middleware

metadata:

  name: oauth-headers

  namespace: default

spec:

  headers:

    sslRedirect: true

    stsSeconds: 315360000

    browserXssFilter: true

    contentTypeNosniff: true

    forceSTSHeader: true

    stsIncludeSubdomains: true

    stsPreload: true

    frameDeny: true

{% endhighlight %}

<p>	
</p>
<p></details><br>
</p>
<p>The middlewares are used to intercept the request and send it to the OAuth2 Proxy when it detects that you are not authenticated by means of a <code>401 Unauthorized</code> http status code being returned.
</p>
<p>The forwardAuth address can be set to a fully qualified domain name but it should be noted that DNS for that URL will be required. In the example above, we are using the cluster DNS name of the kubernetes service which will always work. If you use a FQDN and the DNS changes or is unreachable, the application won't work.
</p>
<p>The cluster DNS name for the service follows the format <code>servicename.namespace</code>
</p>
<p>The official docs have an <a href="https://oauth2-proxy.github.io/oauth2-proxy/configuration/overview#forwardauth-with-401-errors-middleware" target="_blank">example</a> that uses the <code>/oauth2/auth</code> endpoint in the address, however, I have found that this does not always work, so you should use the <code>/oauth2/auth_or_start</code> endpoint instead as per my example.
</p>
<p>See also: <a href="https://github.com/oauth2-proxy/oauth2-proxy/issues/46" target="_blank">https://github.com/oauth2-proxy/oauth2-proxy/issues/46</a>
</p>
<h1 id="Checking_progress">Checking progress</h1>
</p>
<p>Once you commmitted these files to your repo and flux has synced the changes with your cluster, you should see the helm release successfully deployed by running <code>kubectl get helmrelease</code>:
</p>
<p>
</p>
<p>
{% highlight yaml %}
NAME           AGE   READY   STATUS
oauth2-proxy   4d    True    Release reconciliation succeeded
{% endhighlight %}
<p>
</p>
<p>You can run <code>kubectl get pods</code> to view the running pods:
</p>
<p>
</p>
{% highlight yaml %}
NAME                            READY   STATUS    RESTARTS   AGE
oauth2-proxy-59cb698789-mtmwq   1/1     Running   0          12h
{% endhighlight %}
<p>
</p>
<p>If you've configured your DNS, you should be able to connect to OAuth2 Proxy in a web browser. Since we've configured the upstream as <code>static://202</code>, we're greeted with a white page with the word <code>Authenticated</code> in the top left corner.
</p>
<img src="../../../assets/images/oauth2-proxy-authenticated.png" alt="Blank authenticated page">
</p>
<h1 id="Deploying_app">Deploying an application behind OAuth2 Proxy</h1>
</p>
<p>To see OAuth2 Proxy providing authentication to another application, we first need to deploy one with an ingress using Traefik.
</p>
<p>Any application should do but, for this example, we will use a simple hello world style application called Hello Kubernetes.
</p>
<p>Similar to what we've done with Traefik and OAuth2 Proxy, we need a helm release and an ingress. In this case, we will need a git repository manifest instead of a helm repository.
</p>
<p>First, we'll deploy the application without placing it behind OAuth2 Proxy to make sure it's reachable.
</p>
<p>	
</p>
<h2 id="Deploying_git_repo">Deploying the git repository</h2>
</p>
<p><details>
</p>
<summary>View code</summary>
{% highlight yaml %}

apiVersion: source.toolkit.fluxcd.io/v1beta2

kind: GitRepository

metadata:

  name: hello-kubernetes-charts

  namespace: default

spec:

  interval: 5m0s

  url: https://github.com/paulbouwer/hello-kubernetes

  ref:

    branch: main

  ignore: |

    # exclude all

    /*

    # include deploy dir

    !/deploy/helm

{% endhighlight %}

<p>	
</p>
<p></details>
</p>
<h2 id="Deploying_helm_release_2">Deploying the helm release</h2>
</p>
<p><details>
</p>
<summary>View code</summary>
{% highlight yaml %}

apiVersion: helm.toolkit.fluxcd.io/v2beta1

kind: HelmRelease

metadata:

  name: hello-kubernetes

  namespace: default

spec:

  releaseName: hello-kubernetes

  chart:

    spec:

      chart: deploy/helm/hello-kubernetes

      version: 1.0.0

      sourceRef:

        kind: GitRepository

        name: hello-kubernetes-charts

        namespace: default

  interval: 5m

  values:

    service:

      type: ClusterIP

{% endhighlight %}

<p>	
</p>
<p></details>
</p>
<h2 id="Deploying_ingress_2">Deploying the ingress</h2>
</p>
<p><details>
</p>
<summary>View code</summary>
{% highlight yaml %}

kind: Ingress

metadata:

  name: hello-kubernetes

  namespace: default

  annotations:

    traefik.ingress.kubernetes.io/router.tls: "true"

spec:

  ingressClassName: traefik

  rules:

    - host: hello-kubernetes.domain.com

      http:

        paths:

          - path: /

            pathType: Prefix

            backend:

              service:

                name:  hello-kubernetes-hello-kubernetes

                port:

                  number: 80

{% endhighlight %}

<p>	
</p>
<p></details><br>
</p>
<p>These manifests should deploy the Hello Kubernetes application and if you open the URL (the host line in your ingress from above) in your web browser, you should see something like this:
</p>
<img src="../../../assets/images/hello-kubernetes.png" alt="Hello Kubernetes">

<p>In order to force visitors to authenticate, we need to tell Traefik to send unauthenticated requests to OAuth2 Proxy. This is where our middlewares now come into play.
</p>
<p>In our ingress, we need to add an annotation that will send all requests via the OAuth2 Proxy.
</p>
<p>The annotation needs to use the full kubernetes name of the middleware which follows the format <code>namespace-middlewarename@kubernetescrd</code>. Our middlewares are called <code>oauth-auth</code> and <code>oauth-headers</code> so their full names are  <code>default-oauth-auth@kubernetescrd</code> and  <code>default-oauth-headers@kubernetescrd</code>.
</p>
<p>That gives us an ingress manifest looking like this:
</p>
<p><details>
</p>
<summary>View code</summary>
{% highlight yaml %}

kind: Ingress

metadata:

  name: hello-kubernetes

  namespace: default

  annotations:

    traefik.ingress.kubernetes.io/router.tls: "true"

    traefik.ingress.kubernetes.io/router.middlewares: default-oauth-headers@kubernetescrd,default-oauth-auth@kubernetescrd

spec:

  ingressClassName: traefik

  rules:

    - host: hello-kubernetes.domain.com

      http:

        paths:

          - path: /

            pathType: Prefix

            backend:

              service:

                name:  hello-kubernetes-hello-kubernetes

                port:

                  number: 80

{% endhighlight %}

<p>	
</p>
<p></details><br>
</p>
<p>Go back to your application registration in Azure AD and add a new redirect URI and set the value to <code>https://hello-kubernetes.domain.com/oauth2/callback</code>. If you don't do this, you will receive an error message at the Microsoft sign in page after signing in because it isn't allowed to redirect you to the application. Think of the redirect URIs as an allow-list of applications that the app registration is allowed to redirect to.
</p>
<p>Once this is deployed, open the Hello Kubernetes application in a private browsing window so there are no cached cookies.
</p>
<p>You should be redirected to a Microsoft sign in page.
</p>
<img src="../../../assets/images/microsoft-login-page.png" alt="Microsoft login page">

<p>Sign in and then you'll be redirected to the Hello Kubernetes application.
</p>
<h1 id="Ideal_setup">Ideal setup 
</p>
<p>	
</p>
<h2 id="k8s_secrets">Using kubernetes secrets</h2>
</p>
<p>Now we've deployed our application behind OAuth2 Proxy, it's time to make some tweaks. Traefik and Hello Kubernetes are fine as is but we can improve on OAuth2-Proxy.
</p>
<p>The main thing we can do is to convert our arguments into secrets which can then be mounted in our pod. This is better for security and it means we can safely commit our secrets to code without worrying about them being visible in plain text so we don't need a third party secret store like Azure Key Vault, but you can use that if you wish. 
</p>
<p>We won't go into how to use Azure Key Vault to store our secrets and access them on the cluster here. You can find information on how to do that in the <a href="https://learn.microsoft.com/en-us/azure/aks/csi-secrets-store-driver" target="_blank">Microsoft docs</a>. We will focus on encrypting our secrets so we can store them in source control instead.
</p>
<p>To accomplish this, we can use a tool from Mozilla called SOPS. You can follow <a href="https://fluxcd.io/flux/guides/mozilla-sops/" target="_blank">this guide</a>  to get set up with SOPS on your cluster.
</p>
<p>Once you've got SOPS set up on your cluster, create a kubernetes secret in a local branch of your git repo (don't commit this to GitHub):
</p>
<p><details>
</p>
<summary>View code</summary>
{% highlight yaml %}
apiVersion: v1

kind: Secret

metadata:

    name: oauth2-proxy-values

    namespace: default

type: Opaque

stringData:

    azure-tenant: abcd1234

    client-id: abcd1234

    client-secret: abcd1234

    cookie-secret: abcd1234

    extra-jwt-issuers: abcd1234

    oidc-issuer-url: abcd1234

{% endhighlight %}

	
</p>
<p></details><br>
</p>
<p>You can save this file in your oauth2-proxy app folder and then use the sops cli command to encrypt it. Depending on whether you use age or a cloud secret store like Azure Key Vault, the command will vary slightly.
</p>
<p>With age: 
</p>
<p>
</p>
{% highlight yaml %}
sops --encrypt --age <my-age-public-key> --encrypted-regex "^(data|stringData)$" --in-place /path/to/file/oauth2-proxy-values.enc.yaml
{% endhighlight %}
<p>
</p>
<p><a href="https://fluxcd.io/flux/guides/mozilla-sops/#encrypting-secrets-using-age" target="_blank">Source</a>
</p>
<p>With Azure Key Vault: 
</p>
<p>
</p>
{% highlight yaml %}
sops --encrypt --azure-kv https://my-key-vault-name.vault.azure.net/keys/sops-key/abcdefghi123456789 --encrypted-regex "^(data|stringData)$" --in-place /path/to/file/oauth2-proxy-values.enc.yaml
{% endhighlight %}
<p>
</p>
<p><a href="https://github.com/mozilla/sops#24encrypting-using-azure-key-vault"target="_blank">Source</a>
</p>
<p>You can then safely commit the encrypted secret to GitHub because it can only be decrypted using the private key which will only be stored on your cluster, as well as locally on your computer (as with age) or in your cloud secret store (as with Azure Key Vault).
</p>
<p>You can then use volumes, volumeMounts and environment variables to pass your secrets to the OAuth2 Proxy pods.
</p>
<p>In the helm release below, we have set <code>proxyVarsAsSecrets</code> to <code>true</code> and added <code>extraEnv</code>, <code>extraVolumes</code>, <code>extraVolumeMounts</code> and <code>valuesFrom</code> attributes.
</p>
<p>The environment variables are largely the same as the arguments they replace but in upper case and with underscores instead of hyphens.
</p>
<p>More information on this can be found in the OAuth2 Proxy <a href="https://oauth2-proxy.github.io/oauth2-proxy/configuration/overview#environment-variables" target="_blank">docs</a>.
</p>
<p>You could replace all of the <code>extraArgs</code> section with secrets if you wanted to but none of those remaining are sensitive values so there's not much to be gained in doing so and it could make it harder for people looking at your code to understand what's going on and see what arguments are set to what values when troubleshooting.
</p>
<p><details>
</p>
<summary>View code</summary>
{% highlight yaml %}

apiVersion: helm.toolkit.fluxcd.io/v2beta1

kind: HelmRelease

metadata:

  name: oauth2-proxy

  namespace: default

  annotations:

    flux.weave.works/automated: "false"

spec:

  releaseName: oauth2-proxy

  chart:

    spec:

      chart: oauth2-proxy

      version: 6.12.0

      sourceRef:

        kind: HelmRepository

        name: oauth2-proxy-charts

        namespace: default

  interval: 5m

  values:

    extraArgs:

      cookie-domain: ".domain.com"

      email-domain: "*"

      pass-authorization-header: true

      pass-basic-auth: false

      pass-host-header: true

      pass-user-headers: true

      provider: "azure"

      redirect-url: https://oauth-proxy-azure.domain.com/oauth2/callback

      reverse-proxy: true

      set-authorization-header: true

      set-xauthrequest: true

      show-debug-on-error: true

      skip-auth-route: /api

      skip-provider-button: true

      upstream: static://202

      whitelist-domain: ".domain.com"

    redis:

      enabled: false

    extraEnv:

      - name: OAUTH2_PROXY_AZURE_TENANT

        valueFrom:

          secretKeyRef:

            name: oauth2-proxy-values

            key: azure-tenant

      - name: OAUTH2_PROXY_CLIENT_ID

        valueFrom:

          secretKeyRef:

            name: oauth2-proxy-values

            key: client-id

      - name: OAUTH2_PROXY_CLIENT_SECRET

        valueFrom:

          secretKeyRef:

            name: oauth2-proxy-values

            key: client-secret

      - name: OAUTH2_PROXY_COOKIE_SECRET

        valueFrom:

          secretKeyRef:

            name: oauth2-proxy-values

            key: cookie-secret

      - name: OAUTH2_PROXY_EXTRA_JWT_ISSUERS

        valueFrom:

          secretKeyRef:

            name: oauth2-proxy-values

            key: extra-jwt-issuers

      - name: OAUTH2_PROXY_OIDC_ISSUER_URL

        valueFrom:

          secretKeyRef:

            name: oauth2-proxy-values

            key: oidc-issuer-url

    extraVolumes:

      - name: oauth2-proxy-values

        secret:

          secretName: oauth2-proxy-values

    extraVolumeMounts:

      - mountPath: "/var/oauth2"

        name: oauth2-proxy-values

    ingress:

      annotations:

        traefik.ingress.kubernetes.io/router.tls: "true"

      className: traefik

      enabled: true

      hosts:

        - oauth-proxy-azure.domain.com

    proxyVarsAsSecrets: true

    valuesFrom:

      - name: "oauth2-proxy-values"

        kind: Secret

{% endhighlight %}

	
</p>
<p></details>
</p>
<h1 id="Extras">Extras</h1>
</p>
<p>	
</p>
<h2 id="Redis_cache">Redis cache</h2>
</p>
<p>So far, we have used OAuth2 Proxy to require authentication to access an application that has no authentication mechanism of its own.
</p>
<p>However, you can also use OAuth2 Proxy to perform single sign on (SSO) with applications that require authentication and support SSO because ideally you would not login to Azure AD or Google and then have to login again to your application with a local username and password.
</p>
<p>Some applications will work with the setup above as is, but some may experience errors that prevent you from signing in with SSO.
</p>
<p>In some cases, this can be because of the size of the cookies. By default, the cookie limit in OAuth2 Proxy is 4KB but some authentication providers, e.g. Azure AD, provide much larger cookies.
</p>
<p>If you're having issues using SSO with OAuth2 Proxy, you may see error messages in the pod logs telling you the cookie is too large and that it exceeds the 4KB limit.
</p>
<p>To get around this issue, you can use the bundled redis cache chart to cache these larger cookies for OAuth2 Proxy to use.
</p>
<p>To do this, simply add the required values to your helm release:
</p>
<p><details>
</p>
<summary>View code</summary>
{% highlight yaml %}

    redis:

      enabled: true

      auth:

        enabled: true

        existingSecret: oauth2-proxy-values

        existingSecretPasswordKey: redis-password

      master:

        persistence:

          enabled: true

          existingClaim: oauth2-proxy-redis-master

      replica:

        persistence:

          enabled: true

          existingClaim: redis-data-oauth2-proxy-redis-replicas-0

        replicaCount: 1

    sessionStorage:

      type: redis

      redis:

        existingSecret: oauth2-proxy-values

        standalone:

          connectionUrl: redis://oauth2-proxy-redis-master:6379

{% endhighlight %}

<p>	
</p>
<p></details><br>
</p>
<p>The values that are available are inherited from the upstream chart and you can view them <a href="https://github.com/bitnami/charts/tree/master/bitnami/redis#parameters" target="_blank">here</a>.
</p>
<p>In the example above, I am using an existing persistentVolume and persistentVolumeClaim that I have created separately but you can remove the <code>existingClaim</code> value to tell the chart to create its own persistentVolume and persistentVolumeClaim on the cluster. Be aware, however, that you may experience permissions errors if you have not allowed the cluster to provision storage.
</p>
<p>In the example above, I am also using a secret and environment variable to store the password for redis as detailed in <a href="#k8s_secrets">this section</a> of this guide. You can just add another secret to the yaml file and another environment variable to the helmrelease:
</p>
<p><details>
</p>
<summary>View code</summary>
{% highlight yaml %}

apiVersion: v1

kind: Secret

metadata:

    name: oauth2-proxy-values

    namespace: default

type: Opaque

stringData:

    azure-tenant: abcd1234

    client-id: abcd1234

    client-secret: abcd1234

    cookie-secret: abcd1234

    extra-jwt-issuers: abcd1234

    oidc-issuer-url: abcd1234

    redis-password: abcd1234

{% endhighlight %}

<p>	
</p>
<p></details><br>
</p>
<p><details>
</p>
<summary>View code</summary>
{% highlight yaml %}

extraEnv:

  - name: OAUTH2_PROXY_REDIS_PASSWORD

    valueFrom:

      secretKeyRef:

        name: oauth2-proxy-values

        key: redis-password

{% endhighlight %}

<p>	
</p>
<p></details>
</p>
<h1 id="Summary">Summary</h1>
</p>
<p>In this guide, we've explored how to deploy an application to a kubernetes cluster and how to integrate OAuth2 Proxy with Traefik to force visitors to authenticate to Azure AD before they are allowed access our application.
</p>
<p>YAML files for the helm releases, ingresses and other kubernetes resources can be found in <a href="https://github.com/eannaoceallaigh/oauth2-proxy-docs/tree/main" target="_blank">this GitHub repo</a>. Feel free to fork it and get started deploying OAuth2 Proxy with Traefik on Kubernetes.
</p>
<p>If you have any suggestions on how this guide could be improved or if you've spotted an error that needs fixing, let me know by raising a <a href="https://github.com/eannaoceallaigh/www/issues/new" target="_blank">GitHub issue</a>.
</p>
<p>